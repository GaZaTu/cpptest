#include <iostream>
#include "uv.hpp"
#include "cppcoro/task.hpp"
#include "cppcoro/io_service.hpp"
// #include "cppcoro/generator.hpp"
// #include "cppcoro/on_scope_exit.hpp"
// #include "finally.hpp"

template<typename T>
using task = cppcoro::task<T>;

// template<typename T>
// using generator = cppcoro::generator<T>;

task<int> test1() {
    co_return 1;
}

// generator<uint64_t> fibonacci() {
//   uint64_t a = 0;
//   uint64_t b = 1;

//   while (true) {
//     co_yield b;
//     auto tmp = a;
//     a = b;
//     b += tmp;
//   }
// }

// template<typename T>
// void pollTask(task<T>& tsk, std::function<void()> cb) {
//     uv::check* check = new uv::check();

//     check->start([check, &tsk, cb]() {
//         if (tsk.is_ready()) {
//             auto finally = cppcoro::on_scope_exit([check]() {
//                 delete check;
//             });

//             cb();
//         }
//     });
// }

// cppcoro::io_service main_io_service;

task<int> async_main() {
    // co_await main_io_service.schedule();

    std::cout << "async_main" << std::endl;
    std::cout << "task:" << (co_await test1()) << std::endl;

    co_return 0;
}

int main() {
    std::cout << "start" << std::endl;

    // uv::timer timer;

    // timer.start(1000, 1000)
    //     .subscribe([](int v) {
    //         std::cout << "timer" << v << std::endl;
    //     });

    // for (auto i : fibonacci()) {
    //     if (i > 1'000'000) break;
    //     std::cout << i << std::endl;
    // }

    task<int> main_task = async_main();

    uv::check check;
    check.start([&main_task]() {
        // main_io_service.process_one_pending_event();
        if (!main_task.done()) {
            main_task.resume();
        }
    });

    uv_run(uv_default_loop(), UV_RUN_DEFAULT);

    std::cout << "end" << std::endl;

    return 0;
}
